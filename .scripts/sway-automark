#!/usr/bin/env python3
import sys
import traceback
from itertools import count
from typing import Callable, Iterable, Iterator
from time import time

import i3ipc as i3  # type: ignore

INTERVAL = 0.2
MARKERS = "JKLIOHNYPU"


def execute(conn: i3.Connection, commands: Iterable[str]) -> None:
    """Execute the commands in the given iterator by sending it to i3/sway, all 
    in one message."""
    payload = "; ".join(commands)
    if payload:
        reply = conn.command(payload)
        result = reply[0].ipc_data
        if not result["success"]:
            raise RuntimeError(
                f"An error for payload '{payload}': {result['error']}")


def handler(fn: Callable[[i3.Connection, i3.Event], Iterator[str]]) \
        -> Callable[[i3.Connection, i3.Event], None]:
    """Modify an iterator of strings such that its contents are executed by i3 
    and any errors printed to stderr."""

    def mod(conn: i3.Connection, *args, **kwargs):
        try:
            execute(conn, fn(conn, *args, **kwargs))
        except Exception:
            print(traceback.format_exc(), file=sys.stderr)
            raise
    return mod


def get_new_mark(exclude: Iterable[str]) -> str:
    for i in count():
        prefix = i * 'b'
        for m in MARKERS:
            mark = prefix + m
            if mark not in exclude:
                return mark
    raise RuntimeError("unreachable state")


class Connection(i3.Connection):

    def __init__(self, *nargs, **kwargs) -> None:
        self.mark_path = ""
        self.mark_time = 0.0
        super().__init__(*nargs, **kwargs)

    def add_markers(self) -> Iterator[str]:
        """Add markers to existing windows."""
        current_marks = self.get_marks()
        tree = self.get_tree()
        for leaf in tree.leaves():
            marks = leaf.marks
            if not marks:
                new_mark = get_new_mark(current_marks)
                current_marks.append(new_mark)
                yield f"[con_id={leaf.id}] mark {new_mark}"

    def reassign_mark(self, mark: str) -> Iterator[str]:
        """Give the currently focused window a specific mark. If that 
        overwrites an existing mark, give the old window a new mark too."""
        current_marks = self.get_marks()
        if mark in current_marks:
            yield f"[con_mark={mark}] mark {get_new_mark(current_marks)}"
        yield "f[{con_id=__focused__]"

    def mark_focus(self, mark: str) -> Iterator[str]:
        """Focus on a window with a particular mark, or refine an earlier call 
        to this command."""
        now = time()
        if now - self.mark_time <= INTERVAL:
            self.mark_path = mark = self.mark_path + mark
        else:
            self.mark_path = ""
        self.mark_time = now

        mark = mark.upper()
        current_marks = self.get_marks()

        # If there is a mark that matches exactly, just focus on it
        if mark in current_marks:
            yield f"[con_mark={mark}] focus"

        # If there are containers with marks to which the current mark is a 
        # prefix, we focus on the first one we find if we descend in focus 
        # order; later calls to mark_focus may refine this.
        elif any(m.startswith(mark) for m in current_marks):
            tree = self.get_tree()
            for leaf in focus_order(tree):
                if any(m.startswith(mark) for m in leaf.marks):
                    yield f"[con_id={leaf.id}] focus"
                    break
        else:
            self.mark_time = 0.0

    # @handler
    # def rename_workspace(self, event: i3.WindowEvent) -> Iterator[str]:
    #     """An event handler to rename workspaces when a window is given a 
    #     mark."""
    #     tree = self.get_tree()
    #     con = tree.find_by_id(event.container.id)
    #     ws = con.workspace()
    #     marks = set(m for leaf in ws.leaves() for m in leaf.marks)
    #     new = "+".join(sorted(marks))
    #     yield f"rename workspace \"{ws.name}\" \"{new}\""

    @handler
    def add_marker(self, event: i3.WindowEvent) -> Iterator[str]:
        """An event handler that adds a marker to every new window."""
        con_id = event.container.id
        current_marks = self.get_marks()
        new_mark = get_new_mark(current_marks)
        yield f"[con_id={con_id}] mark {new_mark}"

    @handler
    def execute_commands(self, event: i3.TickEvent) -> Iterator[str]:
        """The tick event is used to avoid having to reimplement inter-process 
        communication: we can just use `i3msg`/`swaymsg -t send_tick automarker 
        message` to pass a message to this process."""

        command = event.payload.split()
        try:
            if command[0] != "automarker":
                return
        except IndexError:
            return

        cmd = command[1]
        if cmd == "focus_mark":
            yield from self.mark_focus(command[2])
        elif cmd == "focus_mark_aux":
            raise NotImplementedError
        elif cmd == "cycle":
            raise NotImplementedError
        elif cmd == "cycle_aux":
            raise NotImplementedError
        elif cmd == "swap_aux":
            raise NotImplementedError
        elif cmd == "toggle_aux":
            yield from self.toggle()
        elif cmd == "balance":
            raise NotImplementedError


if __name__ == "__main__":
    conn = Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, Connection.add_marker)
    conn.on(i3.Event.TICK, Connection.execute_commands)
    execute(conn, conn.add_markers())
    conn.main()
