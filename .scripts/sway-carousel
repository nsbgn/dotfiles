#!/usr/bin/env python3
"""
This is a set of commands to reduce the mental overhead of using Sway and i3. 
Each virtual desktop becomes a carousel that shows at most two windows.

Rationale: I don't find myself ever benefiting from having more than two 
windows open on the same screen at any one time. (Maybe three, if there's a 
video playing and I pretend to multitask.) So, rather than manually arranging 
windows, or implementing elaborate and abstract ways to do so automatically, I 
think it's better to go for a more tangible metaphor: every desktop shows only 
the active window, plus, optionally, a reference window to the side of it. It 
is tiled horizontally if the aspect ratio exceeds 1, and vertically otherwise.

What I try to make easier is not the *layout*, but leafing through the pile to 
find the sheet you need. I try to keep the amount of keyboard shortcuts or 
touchscreen gestures small. Every window gets automatically assigned a 
one-letter label, so that you can instantly bring it to focus. In addition to 
the static labels, there is one dynamic label that switches between the active 
and reference windows, and two that cycle forward or backward through the 
inactive windows.

To stay as environment-agnostic as possible, command should make just as much 
sense on stacking window managers (Wayfire/labwc) or terminal multiplexers 
(tmux).
"""
# *Unicode*: Use labels from the Unicode enclosed alphanumeric supplement:
# ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ
# Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ
# 🅐 🅑 🅒 🅓 🅔 🅕 🅖 🅗 🅘 🅙 🅚 🅛 🅜 🅝 🅞 🅟 🅠 🅡 🅢 🅣 🅤 🅥 🅦 🅧 🅨 🅩
# ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳
# ➊ ➋ ➌ ➍ ➎ ➏ ➐ ➑ ➒ ➓


import sys
import traceback
from typing import Callable, Iterable, Iterator

import i3ipc as i3  # type: ignore


def execute(conn: i3.Connection, commands: Iterable[str]) -> None:
    """Execute the commands in the given iterator by sending it to i3/sway, all 
    in one message."""
    payload = "; ".join(commands)
    if payload:
        reply = conn.command(payload)
        result = reply[0].ipc_data
        if not result["success"]:
            raise RuntimeError(
                f"An error for payload '{payload}': {result['error']}")


def handler(fn: Callable[[i3.Connection, i3.Event], Iterator[str]]) \
        -> Callable[[i3.Connection, i3.Event], None]:
    """Modify an iterator of strings such that its contents are executed by i3 
    and any errors printed to stderr."""

    def mod(conn: i3.Connection, *args, **kwargs):
        try:
            execute(conn, fn(conn, *args, **kwargs))
        except Exception:
            print(traceback.format_exc(), file=sys.stderr)
            raise
    return mod


def index(con: i3.Con) -> int:
    """Find the index position of the container in its tree."""
    parent = con.parent
    assert parent
    return parent.nodes.index(con)


def find_focus(con: i3.Con) -> i3.Con:
    """Find the leaf window to get focus once this container gets focus."""
    while con.focus:
        i = con.focus[0]
        for c in con.nodes:
            if c.id == i:
                con = c
                break
    return con


def find_pile(con: i3.Con) -> i3.Con:
    """Find the top-level container to which the given container belongs."""
    while con.parent and con.parent.type != "workspace":
        con = con.parent
    assert con.parent and con.parent.type == "workspace"
    return con


def find_sibling(con: i3.Con, forward: bool = True) -> i3.Con:
    """Find the sibling node of the given node."""
    parent = con.parent
    return parent.nodes[(index(con) + (1 if forward else -1))
        % len(parent.nodes)]


def find_empty_workspace(tree: i3.Con) -> tuple[int, int, int]:
    """Return a tuple containing the number of the lowest-numbered empty 
    workspace, plus the numbers of the closest occupied predecessor and 
    successor workspaces."""
    workspaces = tree.workspaces()
    for counter, ws in enumerate(workspaces, start=1):
        i = ws.num
        if counter != i or not ws.nodes:
            return (counter - 1 or len(workspaces), counter, i)
    n = len(workspaces)
    return (n, n + 1, 1)


def layout_to_dir(layout: str, forward: bool = True):
    if layout in ('splith', 'tabbed'):
        return 'right' if forward else 'left'
    else:
        assert layout in ('splith', 'tabbed')
        return 'down' if forward else 'up'


class Connection(i3.Connection):

    def __init__(self, *nargs, **kwargs) -> None:
        super().__init__(*nargs, **kwargs)

    def cycle_workspace(self, forward: bool) -> Iterator[str]:
        """Focus on the next or previous occupied workspace, or the 
        lowest-numbered empty workspace --- whichever is first."""
        tree = self.get_tree()
        workspaces = tree.workspaces()
        cur = tree.find_focused().workspace().num
        pre, empty, succ = find_empty_workspace(workspaces)

        if cur != empty and (
                (forward and cur == pre) or (not forward and cur == succ)):
            yield f"workspace number {empty}"
        else:
            yield f"workspace {dir}"

    def new_workspace(self) -> Iterator[str]:
        yield f"workspace number {find_empty_workspace(self.get_tree())}"

    def cycle_pile(self, forward: bool = True) \
            -> Iterator[str]:
        """Cycle between top-level containers. Focus will be given to the 
        focused window on the first pile, then the second, and so on."""
        # TODO and floating windows
        tree = self.get_tree()
        focused = tree.find_focused()
        con = find_focus(find_sibling(find_pile(focused), forward))
        yield f"[con_id={con.id}] focus"

    def cycle_leaf(self, forward: bool) -> Iterator[str]:
        """Cycle focus between the leaf windows of the pile currently in 
        focus."""
        tree = self.get_tree()
        focused = tree.find_focused()
        if not focused:
            return
        leaves = focused.parent.leaves()
        i = (leaves.index(focused) + (1 if forward else -1)) % len(leaves)
        yield f"[con_id={leaves[i].id}] focus"

    def move_out(self, con: i3.Con, forward: bool = True) -> Iterator[str]:
        """Move a container to just outside its parent container."""
        # We must use a directional move here, because you can't mark the 
        # workspace container, and moving to a lower-level container puts it 
        # inside the container instead of next to it (unless it's a leaf)
        parent = con.parent
        d = layout_to_dir(parent.layout, forward)
        idx = index(con)
        for _ in range(len(parent.nodes) - idx if forward else idx + 1):
            yield f"[con_id={con.id}] move {d}"

    def move_to(self, src: i3.Con, target: i3.Con,
            before: bool = False) -> Iterator[str]:
        assert target.type != "workspace"
        yield f"[con_id={target.id}] mark _tmp"
        yield f"[con_id={src.id}] move container to mark _tmp"
        yield f"[con_id={target.id}] unmark _tmp"
        if before:
            parent = target.parent
            d = layout_to_dir(parent.layout, forward=False)
            yield f"[con_id={src.id}] move {d}"

    def move_pile(self, forward: bool = True) -> Iterator[str]:
        """Move the focused window in the current pile to the sibling pile in 
        the same workspace. Create one if necessary."""
        tree = self.get_tree()
        focused = tree.find_focused()
        workspace = focused.workspace()
        if len(workspace.nodes) <= 1:
            yield from self.move_out(focused, forward)
            yield f"[con_id={focused.id}] splitt"
            yield f"[con_id={focused.id}] layout tabbed"
        else:
            pile = find_sibling(find_pile(focused), forward)
            yield from self.move_to(focused, pile)
            yield f"[con_id={focused.id}] focus"

    def toggle(self) -> Iterator[str]:
        """Toggle between dual and single-pane view."""
        tree = self.get_tree()
        con = tree.find_focused()
        assert con
        ws = con.workspace()

        if len(ws.nodes) == 1:
            yield from self.move_out(con)
            yield from self.balance(None)

    @handler
    def balance_handler(self, event: i3.WindowEvent) -> Iterator[str]:
        yield from self.balance(event)

    def balance(self, event: i3.WindowEvent | None) -> Iterator[str]:
        """Balance the windows on a desktop. That is, make sure there's at most 
        two tabbed top-level containers, with the active window of the first 
        container to its rightmost tab and the active window of the second 
        container on its leftmost tab, and each container having half the total 
        number of windows.


        2.  Rotate windows furthest from the active window to the other end of 
        the other container until the tabs are balanced."""
        tree = self.get_tree()
        con = tree.find_by_id(event.container.id) if event else tree.find_focused()
        ws = con.workspace()

        if len(ws.nodes) > 1:
            fst = ws.nodes[0]
            snd = ws.nodes[1]

            if fst.layout == "none":
                fst_wins = [fst]
                fst_con_id = fst.id
            else:
                fst_wins = fst.leaves()
                fst_con_id = fst.focus[0]

            if snd.layout == "none":
                snd_wins = [snd]
                snd_con_id = snd.id
            else:
                snd_wins = snd.leaves()
                snd_con_id = snd.focus[0]

            # Put all top-level windows inside a tabbed container. We cannot do 
            # this if there's only one singleton pile, since it'll just change 
            # the workspace orientation
            for con in ws.nodes[:2]:
                if con.layout == "none":
                    yield f"[con_id={con.id}] splitt"
                    yield f"[con_id={con.id}] layout tabbed"

            # Every additional container just gets moved onto the second one
            if len(ws.nodes) > 2:
                for pile in ws.nodes[2:]:
                    for leaf in pile.leaves():
                        yield from self.move_to(leaf, snd[-1])
                        snd.append(leaf)

            # Push windows to the left of the active window of the first 
            # container to the right of the active window on the second 
            # container, and vice versa.
            fst_idx, fst_con = next((i, c)
                for i, c in enumerate(fst_wins) if c.id == fst_con_id)
            snd_idx, snd_con = next((i, c)
                for i, c in enumerate(snd_wins) if c.id == snd_con_id)

            print(fst_idx, snd_idx)

            for con in reversed(fst_wins[fst_idx:]):
                yield from self.move_to(con, snd_con)
            for con in snd_wins[:snd_idx]:
                yield from self.move_to(con, fst_con, before=True)

    @handler
    def execute_commands(self, event: i3.TickEvent) -> Iterator[str]:
        """The tick event is used to avoid having to reimplement inter-process 
        communication: we can just use `i3msg`/`swaymsg -t send_tick message` 
        to pass a message to this process."""
        command = event.payload.split()
        try:
            if command[0] != "pilingwm":
                return
        except IndexError:
            return

        cmd = command[1]
        if cmd == "cycle":
            raise NotImplementedError
        elif cmd == "cycle_aux":
            raise NotImplementedError
        elif cmd == "swap_aux":
            raise NotImplementedError
        elif cmd == "toggle_aux":
            yield from self.toggle()
        elif cmd == "balance":
            raise NotImplementedError

        # if cmd == "mark_focus":
        #     yield from self.mark_focus(command[2])
        # elif cmd == "mark_periphery":
        #     raise NotImplementedError
        # elif cmd == "mark_move":
        #     raise NotImplementedError
        # elif cmd == "mark_reassign":
        #     yield from self.mark_reassign(command[2])
        # elif cmd == "new_workspace":
        #     yield from self.new_workspace()
        # elif cmd == "pile_focus_shift":
        #     yield from self.cycle_pile()
        # elif cmd == "pile_move":
        #     yield from self.move_pile()
        # elif cmd == "win_focus_next":
        #     yield from self.cycle_leaf(True)
        # elif cmd == "win_focus_prev":
        #     yield from self.cycle_leaf(False)


if __name__ == "__main__":
    conn = Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_FOCUS, Connection.balance_handler)
    # conn.on(i3.Event.WINDOW_MARK, Connection.rename_workspace)
    conn.on(i3.Event.TICK, Connection.execute_commands)
    conn.main()
