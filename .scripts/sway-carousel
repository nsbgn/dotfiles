#!/usr/bin/env python3
"""
This is a set of commands to reduce the mental overhead of using Sway and i3. 
Each virtual desktop becomes a carousel that shows at most two windows.

Rationale: I don't find myself ever benefiting from having more than two 
windows open on the same screen at any one time. (Maybe three, if there's a 
video playing and I pretend to multitask.) So, rather than manually arranging 
windows, or implementing elaborate and abstract ways to do so automatically, I 
think it's better to go for a more tangible metaphor: every desktop shows only 
the active window, plus, optionally, a reference window to the side of it. It 
is tiled horizontally if the aspect ratio exceeds 1, and vertically otherwise.

What I try to make easier is not the *layout*, but leafing through the pile to 
find the sheet you need. I try to keep the amount of keyboard shortcuts or 
touchscreen gestures small. Every window gets automatically assigned a 
one-letter label, so that you can instantly bring it to focus. In addition to 
the static labels, there is one dynamic label that switches between the active 
and reference windows, and two that cycle forward or backward through the 
inactive windows.

To stay as environment-agnostic as possible, command should make just as much 
sense on stacking window managers (Wayfire/labwc) or terminal multiplexers 
(tmux).
"""
# *Unicode*: Use labels from the Unicode enclosed alphanumeric supplement:
# ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ
# Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ
# 🅐 🅑 🅒 🅓 🅔 🅕 🅖 🅗 🅘 🅙 🅚 🅛 🅜 🅝 🅞 🅟 🅠 🅡 🅢 🅣 🅤 🅥 🅦 🅧 🅨 🅩
# ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳
# ➊ ➋ ➌ ➍ ➎ ➏ ➐ ➑ ➒ ➓


import sys
import traceback
from itertools import count
from typing import Callable, Iterable, Iterator
from time import time

import i3ipc as i3  # type: ignore

INTERVAL = 0.2
MARKERS = "JKLIOHNYPU"


def execute(conn: i3.Connection, commands: Iterable[str]) -> None:
    """Execute the commands in the given iterator by sending it to i3/sway, all 
    in one message."""
    payload = "; ".join(commands)
    if payload:
        reply = conn.command(payload)
        result = reply[0].ipc_data
        if not result["success"]:
            raise RuntimeError(
                f"An error for payload '{payload}': {result['error']}")


def handler(fn: Callable[[i3.Connection, i3.Event], Iterator[str]]) \
        -> Callable[[i3.Connection, i3.Event], None]:
    """Modify an iterator of strings such that its contents are executed by i3 
    and any errors printed to stderr."""

    def mod(conn: i3.Connection, *args, **kwargs):
        try:
            execute(conn, fn(conn, *args, **kwargs))
        except Exception:
            print(traceback.format_exc(), file=sys.stderr)
            raise
    return mod


def get_new_mark(exclude: Iterable[str]) -> str:
    for i in count():
        prefix = i * 'b'
        for m in MARKERS:
            mark = prefix + m
            if mark not in exclude:
                return mark
    raise RuntimeError("unreachable state")


def focus_order(con: i3.Con) -> Iterator[i3.Con]:
    """Iterate through the leaves of a container, starting with the container 
    that most recently recieved focus, the ones around it, and so on."""
    for n in sorted(con.nodes, key=lambda x: con.focus.index(x.id)):
        yield from focus_order(n)
    yield con


def index(con: i3.Con) -> int:
    """Find the index position of the container in its tree."""
    parent = con.parent
    assert parent
    return parent.nodes.index(con)


def find_focus(con: i3.Con) -> i3.Con:
    """Find the leaf window to get focus once this container gets focus."""
    while con.focus:
        i = con.focus[0]
        for c in con.nodes:
            if c.id == i:
                con = c
                break
    return con


def find_pile(con: i3.Con) -> i3.Con:
    """Find the top-level container to which the given container belongs."""
    while con.parent and con.parent.type != "workspace":
        con = con.parent
    assert con.parent and con.parent.type == "workspace"
    return con


def find_sibling(con: i3.Con, forward: bool = True) -> i3.Con:
    """Find the sibling node of the given node."""
    parent = con.parent
    return parent.nodes[(index(con) + (1 if forward else -1))
        % len(parent.nodes)]


def find_empty_workspace(tree: i3.Con) -> tuple[int, int, int]:
    """Return a tuple containing the number of the lowest-numbered empty 
    workspace, plus the numbers of the closest occupied predecessor and 
    successor workspaces."""
    workspaces = tree.workspaces()
    for counter, ws in enumerate(workspaces, start=1):
        i = ws.num
        if counter != i or not ws.nodes:
            return (counter - 1 or len(workspaces), counter, i)
    n = len(workspaces)
    return (n, n + 1, 1)


class Connection(i3.Connection):

    def __init__(self, *nargs, **kwargs) -> None:
        self.mark_path = ""
        self.mark_time = 0.0
        super().__init__(*nargs, **kwargs)

    def cycle_workspace(self, forward: bool) -> Iterator[str]:
        """Focus on the next or previous occupied workspace, or the 
        lowest-numbered empty workspace --- whichever is first."""
        tree = self.get_tree()
        workspaces = tree.workspaces()
        cur = tree.find_focused().workspace().num
        pre, empty, succ = find_empty_workspace(workspaces)

        if cur != empty and (
                (forward and cur == pre) or (not forward and cur == succ)):
            yield f"workspace number {empty}"
        else:
            yield f"workspace {dir}"

    def new_workspace(self) -> Iterator[str]:
        yield f"workspace number {find_empty_workspace(self.get_tree())}"

    def pack_workspaces(self) -> Iterator[str]:
        """Reorder workspaces so that they are packed tight."""
        tree = self.get_tree()
        for i, ws in enumerate(tree.workspaces(), start=1):
            if ws.num != i:  # No need to do anything if we're not out of order
                for c in ws.nodes:
                    yield (f"[con_id={c.id}] move container "
                           f"to workspace number {i}")

    def cycle_pile(self, forward: bool = True) \
            -> Iterator[str]:
        """Cycle between top-level containers. Focus will be given to the 
        focused window on the first pile, then the second, and so on."""
        # TODO and floating windows
        tree = self.get_tree()
        focused = tree.find_focused()
        con = find_focus(find_sibling(find_pile(focused), forward))
        yield f"[con_id={con.id}] focus"

    def cycle_leaf(self, forward: bool) -> Iterator[str]:
        """Cycle focus between the leaf windows of the pile currently in 
        focus."""
        tree = self.get_tree()
        focused = tree.find_focused()
        if not focused:
            return
        leaves = focused.parent.leaves()
        i = (leaves.index(focused) + (1 if forward else -1)) % len(leaves)
        yield f"[con_id={leaves[i].id}] focus"

    def move_out(self, con: i3.Con, forward: bool = True) -> Iterator[str]:
        """Move a container to just outside its parent container."""
        # We must use a directional move here, because you can't mark the 
        # workspace container, and moving to a lower-level container puts it 
        # inside the container instead of next to it (unless it's a leaf)
        parent = con.parent
        layout = parent.layout
        if layout in ('splith', 'tabbed'):
            d = 'right' if forward else 'left'
        else:
            assert layout in ('splith', 'tabbed')
            d = 'down' if forward else 'up'

        idx = index(con)
        for _ in range(len(parent.nodes) - idx if forward else idx + 1):
            yield f"[con_id={con.id}] move {d}"

    def move_to(self, src: i3.Con, target: i3.Con) -> Iterator[str]:
        assert target.type != "workspace"
        yield f"[con_id={target.id}] mark _tmp"
        yield f"[con_id={src.id}] move container to mark _tmp"
        yield f"[con_id={target.id}] unmark _tmp"

    def move_pile(self, forward: bool = True) -> Iterator[str]:
        """Move the focused window in the current pile to the sibling pile in 
        the same workspace. Create one if necessary."""
        tree = self.get_tree()
        focused = tree.find_focused()
        workspace = focused.workspace()
        if len(workspace.nodes) <= 1:
            yield from self.move_out(focused, forward)
            yield f"[con_id={focused.id}] splitt"
            yield f"[con_id={focused.id}] layout tabbed"
        else:
            pile = find_sibling(find_pile(focused), forward)
            yield from self.move_to(focused, pile)
            yield f"[con_id={focused.id}] focus"

    def add_markers(self) -> Iterator[str]:
        """Add markers to existing windows."""
        current_marks = self.get_marks()
        tree = self.get_tree()
        for leaf in tree.leaves():
            marks = leaf.marks
            if not marks:
                new_mark = get_new_mark(current_marks)
                current_marks.append(new_mark)
                yield f"[con_id={leaf.id}] mark {new_mark}"

    def reassign_mark(self, mark: str) -> Iterator[str]:
        """Give the currently focused window a specific mark. If that 
        overwrites an existing mark, give the old window a new mark too."""
        current_marks = self.get_marks()
        if mark in current_marks:
            yield f"[con_mark={mark}] mark {get_new_mark(current_marks)}"
        yield "f[{con_id=__focused__]"

    def mark_focus(self, mark: str) -> Iterator[str]:
        """Focus on a window with a particular mark, or refine an earlier call 
        to this command."""
        now = time()
        if now - self.mark_time <= INTERVAL:
            self.mark_path = mark = self.mark_path + mark
        else:
            self.mark_path = ""
        self.mark_time = now

        mark = mark.upper()
        current_marks = self.get_marks()

        # If there is a mark that matches exactly, just focus on it
        if mark in current_marks:
            yield f"[con_mark={mark}] focus"

        # If there are containers with marks to which the current mark is a 
        # prefix, we focus on the first one we find if we descend in focus 
        # order; later calls to mark_focus may refine this.
        elif any(m.startswith(mark) for m in current_marks):
            tree = self.get_tree()
            for leaf in focus_order(tree):
                if any(m.startswith(mark) for m in leaf.marks):
                    yield f"[con_id={leaf.id}] focus"
                    break
        else:
            self.mark_time = 0.0

    # @handler
    # def rename_workspace(self, event: i3.WindowEvent) -> Iterator[str]:
    #     """An event handler to rename workspaces when a window is given a 
    #     mark."""
    #     tree = self.get_tree()
    #     con = tree.find_by_id(event.container.id)
    #     ws = con.workspace()
    #     marks = set(m for leaf in ws.leaves() for m in leaf.marks)
    #     new = "+".join(sorted(marks))
    #     yield f"rename workspace \"{ws.name}\" \"{new}\""

    @handler
    def add_marker(self, event: i3.WindowEvent) -> Iterator[str]:
        """An event handler that adds a marker to every new window."""
        con_id = event.container.id
        current_marks = self.get_marks()
        new_mark = get_new_mark(current_marks)
        yield f"[con_id={con_id}] mark {new_mark}"

    @handler
    def make_piles(self, event: i3.WindowEvent) -> Iterator[str]:
        """An event handler that makes sure that new windows are put into 
        piles, that is, into top-level containers."""
        tree = self.get_tree()
        con = tree.find_by_id(event.container.id)
        ws = con.workspace()
        npiles = len(ws.nodes)

        # If we opened a window inside an existing pile and there's not yet 
        # multiple piles, we put it into a new pile.
        if npiles == 1:
            pile = ws.nodes[0]
            if len(pile.nodes) > 1:
                yield from self.move_out(con)
                yield f"[con_id={con.id}] splitt"
                yield f"[con_id={con.id}] layout tabbed"

        # Put all top-level windows inside a container. We cannot do this if 
        # there's only one singleton pile, since it'll just change the 
        # workspace orientation
        elif npiles > 1:
            for pile in ws.nodes[:2]:
                if pile.layout == "none":
                    yield f"[con_id={pile.id}] splitt"
                    yield f"[con_id={pile.id}] layout tabbed"

            for pile in ws.nodes[2:]:
                for leaf in pile.leaves():
                    yield from self.move_to(leaf, ws.nodes[1])

    @handler
    def execute_commands(self, event: i3.TickEvent) -> Iterator[str]:
        """The tick event is used to avoid having to reimplement inter-process 
        communication: we can just use `i3msg`/`swaymsg -t send_tick message` 
        to pass a message to this process."""
        command = event.payload.split()
        try:
            if command[0] != "pilingwm":
                return
        except IndexError:
            return

        cmd = command[1]
        if cmd == "main_focus_mark":
            yield from self.mark_focus(command[2])
        elif cmd == "ref_focus_mark":
            raise NotImplementedError
        elif cmd == "main_cycle":
            raise NotImplementedError
        elif cmd == "ref_cycle":
            raise NotImplementedError

        # if cmd == "mark_focus":
        #     yield from self.mark_focus(command[2])
        # elif cmd == "mark_periphery":
        #     raise NotImplementedError
        # elif cmd == "mark_move":
        #     raise NotImplementedError
        # elif cmd == "mark_reassign":
        #     yield from self.mark_reassign(command[2])
        # elif cmd == "new_workspace":
        #     yield from self.new_workspace()
        # elif cmd == "pile_focus_shift":
        #     yield from self.cycle_pile()
        # elif cmd == "pile_move":
        #     yield from self.move_pile()
        # elif cmd == "win_focus_next":
        #     yield from self.cycle_leaf(True)
        # elif cmd == "win_focus_prev":
        #     yield from self.cycle_leaf(False)


if __name__ == "__main__":
    conn = Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, Connection.make_piles)
    conn.on(i3.Event.WINDOW_NEW, Connection.add_marker)
    # conn.on(i3.Event.WINDOW_MARK, Connection.rename_workspace)
    conn.on(i3.Event.TICK, Connection.execute_commands)
    execute(conn, conn.add_markers())
    conn.main()
