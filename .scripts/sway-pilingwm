#!/usr/bin/env python3
import sys
import traceback
from typing import Callable, Iterable, Iterator

import i3ipc as i3  # type: ignore


def execute(conn: i3.Connection, commands: Iterable[str]) -> None:
    """Execute the commands in the given iterator by sending it to i3/sway, all 
    in one message."""
    payload = "; ".join(commands)
    if payload:
        reply = conn.command(payload)
        result = reply[0].ipc_data
        if not result["success"]:
            raise RuntimeError(
                f"An error for payload '{payload}': {result['error']}")


def handler(fn: Callable[[i3.Connection, i3.Event], Iterator[str]]) \
        -> Callable[[i3.Connection, i3.Event], None]:
    """Modify an iterator of strings such that its contents are executed by i3 
    and any errors printed to stderr."""

    def mod(conn: i3.Connection, *args, **kwargs):
        try:
            execute(conn, fn(conn, *args, **kwargs))
        except Exception:
            print(traceback.format_exc(), file=sys.stderr)
            raise
    return mod


def index(con: i3.Con) -> int:
    """Find the index position of the container in its tree."""
    parent = con.parent
    assert parent
    return parent.nodes.index(con)


class Connection(i3.Connection):

    def __init__(self, *nargs, **kwargs) -> None:
        super().__init__(*nargs, **kwargs)

    def move_out(self, con: i3.Con, forward: bool = True) -> Iterator[str]:
        """Move a container to just outside its parent container."""
        # We must use a directional move here, because you can't mark the 
        # workspace container, and moving to a lower-level container puts it 
        # inside the container instead of next to it (unless it's a leaf)
        parent = con.parent
        layout = parent.layout
        if layout in ('splith', 'tabbed'):
            d = 'right' if forward else 'left'
        elif layout in ('splith', 'stacked'):
            d = 'down' if forward else 'up'
        else:
            assert layout == "none"

        idx = index(con)
        for _ in range(len(parent.nodes) - idx if forward else idx + 1):
            yield f"[con_id={con.id}] move {d}"

    def move_to(self, src: i3.Con, target: i3.Con) -> Iterator[str]:
        assert target.type != "workspace"
        yield f"[con_id={target.id}] mark _tmp"
        yield f"[con_id={src.id}] move container to mark _tmp"
        yield f"[con_id={target.id}] unmark _tmp"

    @handler
    def make_piles(self, event: i3.WindowEvent) -> Iterator[str]:
        """An event handler that makes sure that new windows are put into 
        piles, that is, into top-level containers."""
        tree = self.get_tree()
        con = tree.find_by_id(event.container.id)
        ws = con.workspace()
        npiles = len(ws.nodes)

        # If we opened a window inside an existing pile and there's not yet 
        # multiple piles, we put it into a new pile.
        if npiles == 1:
            pile = ws.nodes[0]
            if len(pile.nodes) > 1:
                yield from self.move_out(con)
                yield f"[con_id={con.id}] splitt"

        # Put all top-level windows inside a container. We cannot do this if 
        # there's only one singleton pile, since it'll just change the 
        # workspace orientation
        elif npiles > 1:
            for pile in ws.nodes[:2]:
                if pile.layout == "none":
                    yield f"[con_id={pile.id}] splitt"

            for pile in ws.nodes[2:]:
                for leaf in pile.leaves():
                    yield from self.move_to(leaf, ws.nodes[1])


if __name__ == "__main__":
    conn = Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, Connection.make_piles)
    conn.on(i3.Event.WINDOW_FOCUS, Connection.make_piles)
    conn.main()
