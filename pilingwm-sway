#!/usr/bin/env python3
"""Enforce a simple layout. There's a maximum of two panes, one of which is the 
"main" pane (with a single window) and the other is a "supplementary" pane that 
contains tabs for all other windows. The workspace itself is split vertically 
in portrait mode and horizontally in landscape mode, as usual."""

import traceback
import sys
import i3ipc as i3  # type: ignore
from typing import Literal, Iterator, Callable

MAIN: Literal[0, 1] = 1


def wrap_error(fn):
    def mod(*args, **kwargs):
        try:
            fn(*args, **kwargs)
        except Exception:
            print(traceback.format_exc(), file=sys.stderr)
            raise
    return mod


def command(fn: Callable[[i3.Connection], Iterator[str]]) \
        -> Callable[[i3.Connection], None]:
    """Decorator to run an iterator of i3 commands on i3 and raise an error if 
    the result is an error."""

    def mod(conn: i3.Connection, *args, **kwargs) -> None:
        payload = "; ".join(fn(conn, *args, **kwargs))
        reply = conn.command(payload)
        result = reply[0].ipc_data
        if not result["success"]:
            raise RuntimeError(
                f"An error for payload '{payload}': {result['error']}")

    return mod


def find_empty_workspace(workspaces: list[i3.Con]) -> tuple[int, int, int]:
    """Return a tuple containing the lowest-numbered empty workspace, plus its 
    predecessor and successor workspaces."""
    for counter, ws in enumerate(workspaces, start=1):
        i = ws.num
        if counter != i or not ws.nodes:
            return (counter - 1 or len(workspaces), counter, i)
    n = len(workspaces)
    return (n, n + 1, 1)


def focus_workspace(conn: i3.Connection, forward: bool) -> None:
    """Focus on the next or previous occupied workspace, or the lowest-numbered 
    empty workspace --- whichever is first."""
    tree = conn.get_tree()
    workspaces = tree.workspaces()
    cur = tree.find_focused().workspace().num
    pre, empty, succ = find_empty_workspace(workspaces)

    if cur != empty and (
            (forward and cur == pre) or (not forward and cur == succ)):
        conn.command(f"workspace number {empty}")
    else:
        conn.command(f"workspace {dir}")


def pack_workspaces(conn: i3.Connection) -> int:
    """Make sure that workspaces are packed tight, then return the number of 
    the now-empty workspace at the end."""
    tree = conn.get_tree()
    commands = []
    for i, ws in enumerate(tree.workspaces(), start=1):
        if ws.num == i:
            continue  # No need to do anything if we're not out of order
        for con in ws.nodes:
            commands.append(
                f"[con_id={con.id}] move container to workspace number {i}")
    conn.command("; ".join(commands))
    # Return the next workspace or the last one if it was already empty
    return i + 1 if ws.nodes else i


def window_new(conn: i3.Connection, event: i3.WindowEvent) -> None:
    tree = conn.get_tree()
    con = tree.find_by_id(event.container.id)
    ws = con.workspace()
    npiles = len(ws.nodes)

    # If we opened a window inside an existing pile and there's not yet 
    # multiple piles, we put it into a new pile. We must use a directional move 
    # here, because you can't mark the workspace container, and moving to a 
    # lower-level container puts it inside the container instead of next to it 
    # unless it's a leaf
    if npiles == 1:
        pile = ws.nodes[0]
        if len(pile.nodes) > 1:
            conn.command(
                f"[con_id={con.id}] move "
                f"{'right' if ws.layout == 'splith' else 'left'}; "
                f"[con_id={con.id}] splitt; [con_id={con.id}] layout tabbed")

    # Put all top-level windows inside a container. We cannot do this if 
    # there's only one singleton pile, since it'll just change the workspace 
    # orientation
    else:
        assert npiles > 1
        for pile in ws.nodes:
            if pile.layout == "none":
                conn.command(f"[con_id={pile.id}] splitt; [con_id={pile.id}] layout tabbed")


def window_close(conn: i3.Connection, event: i3.WindowEvent) -> None:
    """If the main window has been closed, move the first/last window in the 
    supplementary area to be main window."""
    tree = conn.get_tree()
    for ws in tree.workspaces():
        if len(ws.nodes) == 1:
            con = ws.nodes[0]
            n = len(con.nodes)
            if con.layout == 'tabbed' and n > 1:
                if con.parent.orientation == "vertical":
                    dir = "down" if MAIN else "up"
                else:
                    dir = "right" if MAIN else "left"
                conn.command(
                    f"[con_id={con.nodes[MAIN * (n - 1)].id}] move {dir}")
            else:
                assert n == 1
                conn.command(f"[con_id={con.nodes[0].id}] split none")


def cmd_new_workspace(conn: i3.Connection) -> None:
    conn.command(f"workspace number {pack_workspaces(conn)}")


def find_window_in_pile(con: i3.Con) -> i3.Con:
    """Find the window in a pile that should get focus once the pile gets 
    focus."""
    while con.focus:
        id = con.focus[0]
        for c in con.nodes:
            if c.id == id:
                con = c
    return con


def find_pile(current: i3.Con) -> i3.Con:
    while current.parent and current.parent.type != "workspace":
        current = current.parent
    if not current.parent:
        raise RuntimeError
    else:
        return current


def index(con: i3.Con) -> int:
    """Find the index position of the container in its tree."""
    parent = con.parent
    assert parent
    return parent.nodes.index(con)


def cmd_pile_focus_shift(conn: i3.Connection, forward: bool = True) -> None:
    """Cycle between the top-level panes and floating windows. That is, focus 
    will be given to the focused window on the first top-level pane, then the 
    second, and so on, then the floating windows."""
    tree = conn.get_tree()
    focused = tree.find_focused()
    workspace = focused.workspace()
    piles = workspace.nodes

    cur = find_pile(focused)
    new = piles[(piles.index(cur) + (1 if forward else -1)) % len(piles)]
    con = find_window_in_pile(new)
    conn.command(f"[con_id={con.id}] focus")


@command
def cmd_pile_move(conn: i3.Connection, forward: bool = True) -> Iterator[str]:
    """Move the focused window in the current pile to another pile in the same 
    workspace."""
    tree = conn.get_tree()
    focused = tree.find_focused()
    workspace = focused.workspace()
    piles = workspace.nodes
    cur = find_pile(focused)
    if len(piles) <= 1:
        if workspace.layout == 'splith':
            yield f"[con_id={focused.id}] move right"
        else:
            yield f"[con_id={focused.id}] move left"

        yield f"[con_id={focused.id}] splitt"
        yield f"[con_id={focused.id}] layout tabbed"
    else:
        new = piles[(piles.index(cur) + (1 if forward else -1)) % len(piles)]
        yield f"[con_id={new.id}] mark _tmp"
        yield f"[con_id={focused.id}] move container to mark _tmp"
        yield f"[con_id={new.id}] unmark _tmp"
        yield f"[con_id={focused.id}] focus"


def cmd_pile_focus(conn: i3.Connection, forward: bool,
        insert_empty: bool = True) -> None:
    """Move between piles (top-level panes, occupied workspaces and empty 
    workspaces)."""
    tree = conn.get_tree()
    focused = tree.find_focused()
    if not focused:
        return

    workspace = focused.workspace()
    workspaces = tree.workspaces()
    dir = 1 if forward else -1

    if workspace.nodes:
        new_pile_idx = dir + next(i
            for i, ws in enumerate(workspace.nodes)
            if ws.id == workspace.focus[0])
    else:
        new_pile_idx = -1

    # Selecting piles on the same workspace
    if new_pile_idx >= 0 and new_pile_idx < len(workspace.nodes):
        piletop = find_window_in_pile(workspace.nodes[new_pile_idx])
        piletop.command("focus")

    # .. or spilling over to other workspaces
    else:
        if insert_empty:
            ws_cur_id = workspace.num
            ws_pre_empty_id, ws_empty_id, ws_succ_empty_id = \
                find_empty_workspace(workspaces)
            if ws_cur_id != ws_empty_id and (
                    (forward and ws_cur_id == ws_pre_empty_id)
                    or (not forward and ws_cur_id == ws_succ_empty_id)):
                conn.command(f"workspace number {ws_empty_id}")
                return

        ws_cur_idx = workspaces.index(workspace)
        ws_new_idx = (ws_cur_idx + dir) % len(workspaces)
        ws_new = workspaces[ws_new_idx]
        if ws_new.nodes:
            pile_new = ws_new.nodes[0 if forward else -1]
            win_new = find_window_in_pile(pile_new)
            win_new.command("focus")


def cmd_win_focus(conn: i3.Connection, forward: bool) -> None:
    tree = conn.get_tree()
    focused = tree.find_focused()
    if not focused:
        return
    pile = focused.parent
    if pile.type == 'workspace':
        return
    windows = pile.leaves()
    i = (windows.index(focused) + (1 if forward else -1)) % len(windows)
    conn.command(f"[con_id={windows[i].id}] focus")


def tick(conn: i3.Connection, event: i3.TickEvent) -> None:
    """The tick event is used to avoid having to reimplement inter-process 
    communication: we can just use `swaymsg -t send_tick message` to pass a 
    message to this process."""
    command = event.payload.split()
    try:
        if command[0] != "pilingwm":
            return
    except IndexError:
        return

    cmd = command[1]
    if cmd == "new_workspace":
        cmd_new_workspace(conn)
    elif cmd == "pile_focus_shift":
        cmd_pile_focus_shift(conn)
    elif cmd == "pile_move":
        cmd_pile_move(conn)
    elif cmd == "pile_focus_next":
        cmd_pile_focus(conn, True)
    elif cmd == "pile_focus_prev":
        cmd_pile_focus(conn, False)
    elif cmd == "win_focus_next":
        cmd_win_focus(conn, True)
    elif cmd == "win_focus_prev":
        cmd_win_focus(conn, False)


if __name__ == "__main__":
    conn = i3.Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, wrap_error(window_new))
    # conn.on(i3.Event.WINDOW_CLOSE, wrap_error(window_close))
    conn.on(i3.Event.TICK, wrap_error(tick))
    conn.main()
