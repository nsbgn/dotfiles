#!/usr/bin/env python3
"""Enforce a simple layout. There's a maximum of two panes, one of which is the 
"main" pane (with a single window) and the other is a "supplementary" pane that 
contains tabs for all other windows. The workspace itself is split vertically 
in portrait mode and horizontally in landscape mode, as usual."""

import i3ipc as i3  # type: ignore
from typing import Literal

MAIN: Literal[0, 1] = 1


def command(payload: str, on: i3.Con | i3.Connection) -> None:
    reply = on.command(payload)
    result = reply[0].ipc_data
    if not result["success"]:
        raise RuntimeError(f"{payload}: {result['error']}")


def find_empty_workspace(workspaces: list[i3.Con]) -> tuple[int, int, int]:
    """Return a tuple containing the lowest-numbered empty workspace, plus its 
    predecessor and successor workspaces."""
    for counter, ws in enumerate(workspaces, start=1):
        i = ws.num
        if counter != i or not ws.nodes:
            return (counter - 1 or len(workspaces), counter, i)
    n = len(workspaces)
    return (n, n + 1, 1)


def focus_workspace(conn: i3.Connection, forward: bool) -> None:
    """Focus on the next or previous occupied workspace, or the lowest-numbered 
    empty workspace --- whichever is first."""
    tree = conn.get_tree()
    workspaces = tree.workspaces()
    cur = tree.find_focused().workspace().num
    pre, empty, succ = find_empty_workspace(workspaces)

    if cur != empty and (
            (forward and cur == pre) or (not forward and cur == succ)):
        conn.command(f"workspace number {empty}")
    else:
        conn.command(f"workspace {dir}")


def pack_workspaces(conn: i3.Connection) -> int:
    """Make sure that workspaces are packed tight, then return the number of 
    the now-empty workspace at the end."""
    tree = conn.get_tree()
    commands = []
    for i, ws in enumerate(tree.workspaces(), start=1):
        if ws.num == i:
            continue  # No need to do anything if we're not out of order
        for con in ws.nodes:
            commands.append(
                f"[con_id={con.id}] move container to workspace number {i}")
    conn.command("; ".join(commands))
    # Return the next workspace or the last one if it was already empty
    return i + 1 if ws.nodes else i


def window_new(conn: i3.Connection, event: i3.WindowEvent) -> None:
    tree = conn.get_tree()
    con = tree.find_by_id(event.container.id)
    ws = con.workspace()
    if len(ws.nodes) > 2:
        # main = ws.nodes[MAIN]
        supp = ws.nodes[1 - MAIN]
        if supp.layout == "none":
            conn.command(
                f"[con_id={supp.id}] splitt; "
                f"[con_id={supp.id}] layout tabbed")
            tree = conn.get_tree()
            con = tree.find_by_id(event.container.id)
            ws = con.workspace()
            supp = ws.nodes[1 - MAIN]

        assert supp.layout == 'tabbed'
        x = supp.focus[0]
        if con.parent.id != supp.id:
            conn.command(
                f"[con_id={x}] mark _tmp; "
                f"[con_id={con.id}] move container to mark _tmp; "
                f"[con_id={x}] unmark _tmp")


def window_close(conn: i3.Connection, event: i3.WindowEvent) -> None:
    """If the main window has been closed, move the first/last window in the 
    supplementary area to be main window."""
    tree = conn.get_tree()
    for ws in tree.workspaces():
        if len(ws.nodes) == 1:
            con = ws.nodes[0]
            n = len(con.nodes)
            if con.layout == 'tabbed' and n > 1:
                if con.parent.orientation == "vertical":
                    dir = "down" if MAIN else "up"
                else:
                    dir = "right" if MAIN else "left"
                conn.command(
                    f"[con_id={con.nodes[MAIN * (n - 1)].id}] move {dir}")
            else:
                assert n == 1
                conn.command(f"[con_id={con.nodes[0].id}] split none")


def cmd_new_workspace(conn: i3.Connection) -> None:
    conn.command(f"workspace number {pack_workspaces(conn)}")


def find_window_in_pile(con: i3.Con) -> i3.Con:
    """Find the window in a pile that should get focus once the pile gets 
    focus."""
    while con.focus:
        id = con.focus[0]
        for c in con.nodes:
            if c.id == id:
                con = c
    return con


def cmd_pile_focus(conn: i3.Connection, forward: bool,
        insert_empty: bool = True) -> None:
    """Move between piles (top-level panes, occupied workspaces and empty 
    workspaces)."""
    tree = conn.get_tree()
    focused = tree.find_focused()
    if not focused:
        return

    workspace = focused.workspace()
    workspaces = tree.workspaces()
    dir = 1 if forward else -1

    if workspace.nodes:
        new_pile_idx = dir + next(i
            for i, ws in enumerate(workspace.nodes)
            if ws.id == workspace.focus[0])
    else:
        new_pile_idx = -1

    # Selecting piles on the same workspace
    if new_pile_idx >= 0 and new_pile_idx < len(workspace.nodes):
        piletop = find_window_in_pile(workspace.nodes[new_pile_idx])
        piletop.command("focus")

    # .. or spilling over to other workspaces
    else:
        if insert_empty:
            ws_cur_id = workspace.num
            ws_pre_empty_id, ws_empty_id, ws_succ_empty_id = \
                find_empty_workspace(workspaces)
            if ws_cur_id != ws_empty_id and (
                    (forward and ws_cur_id == ws_pre_empty_id)
                    or (not forward and ws_cur_id == ws_succ_empty_id)):
                conn.command(f"workspace number {ws_empty_id}")
                return

        ws_cur_idx = workspaces.index(workspace)
        ws_new_idx = (ws_cur_idx + dir) % len(workspaces)
        ws_new = workspaces[ws_new_idx]
        if ws_new.nodes:
            pile_new = ws_new.nodes[0 if forward else -1]
            win_new = find_window_in_pile(pile_new)
            win_new.command("focus")


def cmd_win_focus(conn: i3.Connection, forward: bool) -> None:
    raise NotImplementedError


def tick(conn: i3.Connection, event: i3.TickEvent) -> None:
    """The tick event is used to avoid having to reimplement inter-process 
    communication: we can just use `swaymsg -t send_tick message` to pass a 
    message to this process."""
    command = event.payload.split()
    try:
        if command[0] != "doublepaned":
            return
    except IndexError:
        return

    cmd = command[1]
    if cmd == "new_workspace":
        cmd_new_workspace(conn)
    elif cmd == "pile_focus_next":
        cmd_pile_focus(conn, True)
    elif cmd == "pile_focus_prev":
        cmd_pile_focus(conn, False)
    elif cmd == "win_focus_next":
        cmd_win_focus(conn, True)
    elif cmd == "win_focus_prev":
        cmd_win_focus(conn, False)


if __name__ == "__main__":
    conn = i3.Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, window_new)
    conn.on(i3.Event.WINDOW_CLOSE, window_close)
    conn.on(i3.Event.TICK, tick)
    conn.main()
