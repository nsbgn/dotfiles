#!/usr/bin/env python3
"""Enforce a simple layout. There's a maximum of two panes, one of which is the 
"main" pane (with a single window) and the other is a "supplementary" pane that 
contains tabs for all other windows. The workspace itself is split vertically 
in portrait mode and horizontally in landscape mode, as usual."""

import i3ipc as i3  # type: ignore
from typing import Literal

MAIN: Literal[0, 1] = 1


def command(payload: str, on: i3.Con | i3.Connection) -> None:
    reply = on.command(payload)
    result = reply[0].ipc_data
    if not result["success"]:
        raise RuntimeError(f"{payload}: {result['error']}")


def unify_container(con: i3.Con, dir: Literal["h", "v"]) -> None:
    """Change container such that all of its children descend from a single 
    container with the given split direction."""
    assert con.layout in ("splith", "splitv")
    if len(con.nodes) > 1:
        x = con.nodes[0]
        if x.type == "none":
            command(f"split{dir}", x)
        else:
            command(f"layout split{dir}", x)
        for y in con.nodes[1:]:
            command("move left" if con.layout == "splith" else "move up", y)


def new_workspace(conn: i3.Connection) -> int:
    """Make sure that workspaces are packed tight, then return the number of 
    the empty workspace at the end."""
    tree = conn.get_tree()
    commands = []
    for i, ws in enumerate(tree.workspaces(), start=1):
        if ws.num == i:
            continue  # No need to do anything if we're not out of order
        for con in ws.nodes:
            commands.append(
                f"[con_id={con.id}] move container to workspace number {i}")
    conn.command("; ".join(commands))
    # Return the next workspace or the last one if it was already empty
    return i + 1 if ws.nodes else i


def window_new(conn: i3.Connection, event: i3.WindowEvent) -> None:
    tree = conn.get_tree()
    con = tree.find_by_id(event.container.id)
    ws = con.workspace()
    if len(ws.nodes) > 2:
        # main = ws.nodes[MAIN]
        supp = ws.nodes[1 - MAIN]
        if supp.layout == "none":
            conn.command(
                f"[con_id={supp.id}] splitt; "
                f"[con_id={supp.id}] layout tabbed")
            tree = conn.get_tree()
            con = tree.find_by_id(event.container.id)
            ws = con.workspace()
            supp = ws.nodes[1 - MAIN]

        assert supp.layout == 'tabbed'
        x = supp.focus[0]
        if con.parent.id != supp.id:
            conn.command(
                f"[con_id={x}] mark _tmp; "
                f"[con_id={con.id}] move container to mark _tmp; "
                f"[con_id={x}] unmark _tmp")


def window_close(conn: i3.Connection, event: i3.WindowEvent) -> None:
    """If the main window has been closed, move the first/last window in the 
    supplementary area to be main window."""
    tree = conn.get_tree()
    for ws in tree.workspaces():
        if len(ws.nodes) == 1:
            con = ws.nodes[0]
            n = len(con.nodes)
            if con.layout == 'tabbed' and n > 1:
                if con.parent.orientation == "vertical":
                    dir = "down" if MAIN else "up"
                else:
                    dir = "right" if MAIN else "left"
                conn.command(
                    f"[con_id={con.nodes[MAIN * (n - 1)].id}] move {dir}")
            else:
                assert n == 1
                conn.command(f"[con_id={con.nodes[0].id}] split none")


def tick(conn: i3.Connection, event: i3.TickEvent) -> None:
    """The tick event is used to avoid having to reimplement inter-process 
    communication: we can just use `swaymsg -t send_tick message` to pass a 
    message to this process."""
    command = event.payload.split()
    try:
        if command[0] != "doublepaned":
            return
    except IndexError:
        return

    if command[1] == "new_workspace":
        conn.command(f"workspace number {new_workspace(conn)}")


if __name__ == "__main__":
    conn = i3.Connection(auto_reconnect=True)
    conn.on(i3.Event.WINDOW_NEW, window_new)
    conn.on(i3.Event.WINDOW_CLOSE, window_close)
    conn.on(i3.Event.TICK, tick)
    conn.main()
